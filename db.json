{"Asset":[{"_id":"themes/hexo-theme-iOS7/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":false},{"_id":"themes/hexo-theme-iOS7/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":false},{"_id":"themes/hexo-theme-iOS7/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":false},{"_id":"themes/hexo-theme-iOS7/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":false},{"_id":"themes/hexo-theme-iOS7/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":false},{"_id":"themes/hexo-theme-iOS7/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":false},{"_id":"themes/hexo-theme-iOS7/source/js/gallery.js","path":"js/gallery.js","modified":false},{"_id":"themes/hexo-theme-iOS7/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":false},{"_id":"themes/hexo-theme-iOS7/source/js/moment.min.js","path":"js/moment.min.js","modified":false},{"_id":"themes/hexo-theme-iOS7/source/css/style.styl","path":"css/style.styl","modified":false},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.eot","path":"css/font/fontawesome-webfont.eot","modified":false},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.svg","path":"css/font/fontawesome-webfont.svg","modified":false},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.ttf","path":"css/font/fontawesome-webfont.ttf","modified":false},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.woff","path":"css/font/fontawesome-webfont.woff","modified":false}],"Cache":[{"_id":"scaffolds/draft.md","mtime":1416188850000},{"_id":"scaffolds/page.md","mtime":1416188850000},{"_id":"scaffolds/photo.md","mtime":1416188850000},{"_id":"scaffolds/post.md","mtime":1416188850000},{"_id":"themes/landscape/Gruntfile.js","mtime":1415712048000},{"_id":"themes/landscape/LICENSE","mtime":1415712048000},{"_id":"themes/landscape/README.md","mtime":1415712048000},{"_id":"themes/landscape/_config.yml","mtime":1415712048000},{"_id":"themes/landscape/package.json","mtime":1415712048000},{"_id":"themes/landscape/scripts/fancybox.js","mtime":1415712048000},{"_id":"themes/landscape/layout/archive.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/category.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/index.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/layout.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/page.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/post.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/tag.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_widget/category.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_widget/archive.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_widget/tag.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/archive.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/article.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/footer.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/head.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/header.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","mtime":1415712048000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","mtime":1415712048000},{"_id":"themes/landscape/source/js/script.js","mtime":1415712048000},{"_id":"themes/landscape/source/css/_extend.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_variables.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/style.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/archive.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/article.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/comment.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/footer.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/header.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_util/grid.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/_util/mixin.styl","mtime":1415712048000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","mtime":1415712048000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","mtime":1415712048000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","mtime":1415712048000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","mtime":1415712048000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","mtime":1415712048000},{"_id":"themes/landscape/source/css/images/banner.jpg","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/blank.gif","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","mtime":1415712048000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","mtime":1415712048000},{"_id":"themes/hexo-theme-iOS7/LICENSE","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/README.md","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/_config.yml","mtime":1416362734000},{"_id":"themes/hexo-theme-iOS7/languages/default.yml","mtime":1416278423000},{"_id":"themes/hexo-theme-iOS7/languages/zh-CN.yml","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/category.ejs","mtime":1416113464000},{"_id":"themes/hexo-theme-iOS7/layout/archive.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/index.ejs","mtime":1415801968000},{"_id":"themes/hexo-theme-iOS7/layout/layout.ejs","mtime":1416124284000},{"_id":"themes/hexo-theme-iOS7/layout/page.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/post.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/tag.ejs","mtime":1416189316000},{"_id":"themes/hexo-theme-iOS7/layout/_widget/category.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_widget/menu.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_widget/recent_posts.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_widget/search.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_widget/tag.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_widget/tagcloud.ejs","mtime":1416277957000},{"_id":"themes/hexo-theme-iOS7/layout/_widget/weibo.ejs","mtime":1416307162000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/after_footer.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/archive.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/article.ejs","mtime":1416276837000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/comment.ejs","mtime":1416362253000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/footer.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/google_analytics.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/head.ejs","mtime":1416124588000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/pagination.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/sidebar.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/tabbar.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/post/category.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/post/copyright.ejs","mtime":1416126992000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/post/gallery.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/post/share.ejs","mtime":1416276850000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/post/tag.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/layout/_partial/post/title.ejs","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/fancybox/blank.gif","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/fancybox/fancybox_loading.gif","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/fancybox/fancybox_overlay.png","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/fancybox/fancybox_sprite.png","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/fancybox/jquery.fancybox.css","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/fancybox/jquery.fancybox.pack.js","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/js/gallery.js","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/js/jquery.imagesloaded.min.js","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/js/moment.min.js","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/style.styl","mtime":1416113508000},{"_id":"themes/hexo-theme-iOS7/source/css/_base/layout.styl","mtime":1416371698000},{"_id":"themes/hexo-theme-iOS7/source/css/_base/utils.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_base/variable.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/archive.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/article.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/comment.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/footer.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/header.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/index.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/sidebar.styl","mtime":1416363173000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/syntax.styl","mtime":1416125594000},{"_id":"themes/hexo-theme-iOS7/source/css/_partial/tabbar.styl","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.eot","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.svg","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.ttf","mtime":1415801550000},{"_id":"themes/hexo-theme-iOS7/source/css/font/fontawesome-webfont.woff","mtime":1415801550000},{"_id":"source/_posts/Object.md","mtime":1416188850000},{"_id":"source/_posts/CSS.md","mtime":1416188850000},{"_id":"source/_posts/haslayoot.md","mtime":1416188850000},{"_id":"source/_posts/js作用域.md","mtime":1416188850000},{"_id":"source/_posts/js面向对象.md","mtime":1416188850000},{"_id":"source/_posts/my-project.md","mtime":1416374970000},{"_id":"source/_posts/this的只读操作.md","mtime":1416188850000},{"_id":"source/_posts/创建dom元素的问题.md","mtime":1416188850000},{"_id":"source/about/index.md","mtime":1416188850000},{"_id":"source/_posts/nodejs热身一.md","mtime":1416376979000}],"Category":[{"name":"css","_id":"fi9s2wsmxh97c8fv","posts":["2g8v2h5wq1dneiqe","4dji7sn1vmedp04e"]},{"name":"javascript","_id":"kpn7j6hexozwxcw3","posts":["yn8699821c12i2sh","0puul5bek9getk4w","k24wuct426886hqr","hwk437tfzbo6axvb","h70fad9faohpc4rc","l2lst50rt9g5qs4i"]},{"name":"JS","_id":"d80nfsuydbakdide","posts":[]},{"name":"js","_id":"2psah6uozjjgxbdg","posts":[]},{"name":"nodejs","_id":"x5nen7h4vpv1cgo3","posts":["kc4xi4n6vm81yt9w"]}],"Page":[{"title":"About Me","date":1400130403000,"content":"<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"keyword\">var</span> about = {</div><div class=\"line\">\t<span class=\"string\">'NickName'</span> : <span class=\"string\">\"towne\"</span>,</div><div class=\"line\">\t<span class=\"string\">'Name'</span> : <span class=\"string\">\"xxxxx\"</span>,</div><div class=\"line\">\t<span class=\"string\">'HomeTown'</span> : <span class=\"string\">\"jiangsu\"</span>,</div><div class=\"line\">\t<span class=\"string\">'Age'</span> : <span class=\"string\">\"25\"</span>,</div><div class=\"line\">\t<span class=\"string\">'location'</span> : <span class=\"string\">\"beijin\"</span>,</div><div class=\"line\">\t\t<span class=\"string\">'Mission'</span> : <span class=\"string\">\"Full Stack developer\"</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n","source":"about/index.md","raw":"\ntitle: About Me\ndate: 2014-05-15 13:06:43\n---\n```\n    var about = {\n\t\t'NickName' : \"towne\",\n\t\t'Name' : \"xxxxx\",\n\t\t'HomeTown' : \"jiangsu\",\n\t\t'Age' : \"25\",\n\t\t'location' : \"beijin\",\n \t\t'Mission' : \"Full Stack developer\"\n\t}\n```\n\n","updated":1416188850000,"path":"about/index.html","excerpt":"","_id":"jq20xnho9jgtrao8","comments":true,"layout":"page"}],"Post":[{"title":"CSS样式规范一","date":1400209875000,"tags":["cinq56dlu69hhr5s"],"categories":["fi9s2wsmxh97c8fv"],"content":"<h2 id=\"元素分类(常规)\">元素分类(常规)</h2>\n<ol>\n<li>块级元素：(display: block) [div, h1 ~ h6, p, ul, ol, dl, li, dt, dd]</li>\n<li>内嵌块元素:(display: inline-block) [img, input]</li>\n<li>内嵌元素：(display: inline) [strong, em, a, span]</li>\n<li>table元素：(display: inline-table)</li>\n</ol>\n<p><strong>css标签元素的分类就好比javascript里面数据类型的分类，如果你拿到一个变量却不知道这个变量的数据类型，你敢用么。可想而知，CSS里面标签元素分类的重要性.</strong></p>\n<p>一.内嵌元素的特性：</p>\n<ol>\n<li>行内元素不会应用width属性，其长度是由内容撑开的</li>\n<li>行内元素不会应用height属性，其高度也是由内容撑开的，但是高度可以通过line-height调节</li>\n<li>行内元素的padding属性只用padding-left和padding-right生效，padding-top和padding-bottom会改变元素范围，但不会对其它元素造成影响</li>\n<li>行内元素的margin属性只有margin-left和margin-right有效，margin-top和margin-bottom无效</li>\n<li>行内元素的overflow属性无效，这个不用多说了</li>\n<li>行内元素的vertical-align属性无效（height属性无效）</li>\n</ol>\n","source":"_posts/CSS.md","raw":"title: CSS样式规范一\ndate: 2014-05-16 11:11:15\ntags: css\ncategories: css\n---\n\n## 元素分类(常规) ##\n1. 块级元素：(display: block) [div, h1 ~ h6, p, ul, ol, dl, li, dt, dd]\n2. 内嵌块元素:(display: inline-block) [img, input]\n3. 内嵌元素：(display: inline) [strong, em, a, span]\n4. table元素：(display: inline-table)\n\n**css标签元素的分类就好比javascript里面数据类型的分类，如果你拿到一个变量却不知道这个变量的数据类型，你敢用么。可想而知，CSS里面标签元素分类的重要性.**\n\n一.内嵌元素的特性：\n\r\n\r\n1. 行内元素不会应用width属性，其长度是由内容撑开的\n2. 行内元素不会应用height属性，其高度也是由内容撑开的，但是高度可以通过line-height调节\n3. 行内元素的padding属性只用padding-left和padding-right生效，padding-top和padding-bottom会改变元素范围，但不会对其它元素造成影响\n4. 行内元素的margin属性只有margin-left和margin-right有效，margin-top和margin-bottom无效\n5. 行内元素的overflow属性无效，这个不用多说了\n6. 行内元素的vertical-align属性无效（height属性无效）","slug":"CSS","updated":1416188850000,"excerpt":"","_id":"2g8v2h5wq1dneiqe","comments":true,"layout":"post","photos":[],"link":""},{"title":"HasLayOut","date":1400560770000,"tags":["kjkc0phd1g8rw3fu"],"categories":["fi9s2wsmxh97c8fv"],"content":"<h3 id=\"什么是layout\">什么是layout</h3>\n","source":"_posts/haslayoot.md","raw":"title: HasLayOut\ndate: 2014-05-20 12:39:30\ntags: layout\ncategories: css\n---\n### 什么是layout ###","slug":"haslayoot","updated":1416188850000,"excerpt":"","_id":"4dji7sn1vmedp04e","comments":true,"layout":"post","photos":[],"link":""},{"title":"Object","date":1403417957000,"tags":["aw2ys0u363x3e3up"],"categories":["kpn7j6hexozwxcw3"],"content":"<h3 id=\"JS对象\">JS对象</h3>\n<hr>\n<p>前几天在HTML5群里头有人问道：Object.defineProperties();当时没太留意，今天想起来，于是翻了一些博客，看了几眼，Object在ECMAScript5中扩展了许多功能；今天就来聊聊这些功能</p>\n<p>1.Object.create()<br>create方法是Object构造函数底下的私有方法。一般我们创建一个对象都是<code>var o = {&quot;a&quot;:1}</code>;这样就相当与<code>new Object()</code>；当然我们还有第三种方法来创建一个对象:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">var</span>  o = <span class=\"built_in\">Object</span>.create({</div><div class=\"line\">\t<span class=\"string\">\"name\"</span> : <span class=\"string\">\"tonwe\"</span>,</div><div class=\"line\">\t<span class=\"string\">\"age\"</span> : <span class=\"number\">24</span>,</div><div class=\"line\">\t<span class=\"string\">\"work\"</span> : <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"working....\"</span>;</div><div class=\"line\">\t\t\t}</div><div class=\"line\">})</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>当然我们一般情况下不会使用到后面两种方式；使用自定义对象的方式不仅简单，性能上也优越。</p>\n","source":"_posts/Object.md","raw":"title: Object\ndate: 2014-06-22 14:19:17\ntags: object\ncategories: javascript\n---\n### JS对象 ###\n\n----------\n\n前几天在HTML5群里头有人问道：Object.defineProperties();当时没太留意，今天想起来，于是翻了一些博客，看了几眼，Object在ECMAScript5中扩展了许多功能；今天就来聊聊这些功能\n\n\n1.Object.create()\ncreate方法是Object构造函数底下的私有方法。一般我们创建一个对象都是`var o = {\"a\":1}`;这样就相当与`new Object()`；当然我们还有第三种方法来创建一个对象:\n\n```\n\t<script type=\"text/javascript\">\n\tvar  o = Object.create({\n\t\t\"name\" : \"tonwe\",\n\t\t\"age\" : 24,\n\t\t\"work\" : function(){\n\t\t\t\t\treturn \"working....\";\n\t\t\t\t}\n\t})\n\t</script>\n```\n当然我们一般情况下不会使用到后面两种方式；使用自定义对象的方式不仅简单，性能上也优越。","slug":"Object","updated":1416188850000,"excerpt":"","_id":"yn8699821c12i2sh","comments":true,"layout":"post","photos":[],"link":""},{"title":"JS作用域","date":1400595484000,"tags":["6ozzr8txhwusnkke"],"categories":["kpn7j6hexozwxcw3"],"content":"<h3 id=\"作用域是JS里面的一个难点\">作用域是JS里面的一个难点</h3>\n<hr>\n<p>一般情况下，我们在写代码的同时，并不会太关心作用域的问题，往往只有程序出错的时候，我们才会考虑是不是作用域的问题。当然作用域的定义，咱们可以自己百度，网上一大堆解释。</p>\n<ol>\n<li>首先我们得先知道什么东西它有作用域，—-变量，肯定的。不管是简单的数字、Bollen或者字符串，还是object或者函数。他们都有作用域.</li>\n<li>然后我们得知道这个鬼作用域在什么时候出现，或者说，什么情况下会有作用域。javascript中只有当遇到函数的时候，作用域才随之会出现。《权威指南》中在变量作用域这一章节有说明。当然许多前辈都提到function是javascript的一等公民。也许原因就在这儿。</li>\n</ol>\n<p>当然就知道上面两点，我们还不能完全搞懂JS的作用域。前提是我们还得先了解JS的运作机理，就是JS是怎么工作的：</p>\n<ol>\n<li>首先 — 预编译，什么是预编译。预编译就是JS会将<code>var</code>定义的变量<strong>名称</strong>和<code>function</code><strong>整体</strong>以及函数的<code>arguments</code><strong>名称</strong>提前保存起来，也就是《权威指南》中提到的声明提前。JS预编译，只会去获取<strong>名称</strong>和<strong>函数整体</strong>，不会进行操作。<a id=\"more\"></a>\n\n</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">\talert(b);</div><div class=\"line\">\talert(a);</div><div class=\"line\">\t<span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</div><div class=\"line\">\ta = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>我们会发现第一次弹出undefined，第二次会报错。说明变量<code>b</code>被预编译了，<code>a</code>却没有。所以只有<code>var</code>过的变量才会被JS与解析。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">\talert(b);</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span><span class=\"params\">()</span></span>{</div><div class=\"line\">\t\tb = <span class=\"number\">4</span>;</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"keyword\">var</span> b = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>我们会发现这次弹出的不是undefined了，而是把整个函数弹出来了，仔细看，发现变量名称与函数名称重名了。在JS的预编译过程中，如果发生变量名称与函数名称重名，那么<code>function</code><strong>整体</strong>会覆盖<code>var</code>定义的变量<strong>名称</strong>；当然如果有两个函数都是<code>function b(){}</code>的话，那么执行程序的通用规则—后者覆盖前者。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span><span class=\"params\">(b)</span></span>{</div><div class=\"line\">\t\talert(b);</div><div class=\"line\">\t\talert(c);</div><div class=\"line\">\t\tc = <span class=\"number\">1</span>;</div><div class=\"line\">\t}</div><div class=\"line\">\ta();</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>在函数内部，参数也会被预编译。其实上面的函数可以看成<code>function a( var b ){···}</code>，仔细发现作用域悄然而生，函数的参数只会在函数内部有效的原因就在于<code>var</code>。</p>\n<ol>\n<li>JS预编译完了之后就是语句的逐行执行。这就和其他语言没什么区别了。</li>\n</ol>\n<p>当我们理解了javascript的工作原理之后，作用域也就不是难事了。</p>\n","source":"_posts/js作用域.md","raw":"title: JS作用域\r\ndate: 2014-05-20 22:18:04\r\ntags: 作用域\r\ncategories: javascript\r\n---\r\n### 作用域是JS里面的一个难点 ###\r\n----------\r\n一般情况下，我们在写代码的同时，并不会太关心作用域的问题，往往只有程序出错的时候，我们才会考虑是不是作用域的问题。当然作用域的定义，咱们可以自己百度，网上一大堆解释。\r\n\r\n1.  首先我们得先知道什么东西它有作用域，---变量，肯定的。不管是简单的数字、Bollen或者字符串，还是object或者函数。他们都有作用域.\r\n2.  然后我们得知道这个鬼作用域在什么时候出现，或者说，什么情况下会有作用域。javascript中只有当遇到函数的时候，作用域才随之会出现。《权威指南》中在变量作用域这一章节有说明。当然许多前辈都提到function是javascript的一等公民。也许原因就在这儿。\r\n\r\n当然就知道上面两点，我们还不能完全搞懂JS的作用域。前提是我们还得先了解JS的运作机理，就是JS是怎么工作的：\r\n\r\n1.  首先 -- 预编译，什么是预编译。预编译就是JS会将`var`定义的变量**名称**和`function`**整体**以及函数的`arguments`**名称**提前保存起来，也就是《权威指南》中提到的声明提前。JS预编译，只会去获取**名称**和**函数整体**，不会进行操作。\r\n<!-- more -->\r\n\r\n```\r\n\t<script type=\"text/javascript\">\r\n\t\talert(b);\r\n\t\talert(a);\r\n\t\tvar b = 1;\r\n\t\ta = 1;\r\n\t</script>\r\n```\r\n我们会发现第一次弹出undefined，第二次会报错。说明变量`b`被预编译了，`a`却没有。所以只有`var`过的变量才会被JS与解析。\r\n```\r\n\t<script type=\"text/javascript\">\r\n\t\talert(b);\r\n\t\tfunction b(){\r\n\t\t\tb = 4;\r\n\t\t}\r\n\t\tvar b = 3;\r\n\t</script>\r\n```\r\n我们会发现这次弹出的不是undefined了，而是把整个函数弹出来了，仔细看，发现变量名称与函数名称重名了。在JS的预编译过程中，如果发生变量名称与函数名称重名，那么`function`**整体**会覆盖`var`定义的变量**名称**；当然如果有两个函数都是`function b(){}`的话，那么执行程序的通用规则--后者覆盖前者。\r\n```\r\n\t<script type=\"text/javascript\">\r\n\t\tfunction a(b){\r\n\t\t\talert(b);\r\n\t\t\talert(c);\r\n\t\t\tc = 1;\r\n\t\t}\r\n\t\ta();\r\n\t</script>\r\n```\r\n在函数内部，参数也会被预编译。其实上面的函数可以看成`function a( var b ){···}`，仔细发现作用域悄然而生，函数的参数只会在函数内部有效的原因就在于`var`。\r\n\r\n2.  JS预编译完了之后就是语句的逐行执行。这就和其他语言没什么区别了。\r\n\r\n当我们理解了javascript的工作原理之后，作用域也就不是难事了。","slug":"js作用域","updated":1416188850000,"excerpt":"<h3 id=\"作用域是JS里面的一个难点\">作用域是JS里面的一个难点</h3>\n<hr>\n<p>一般情况下，我们在写代码的同时，并不会太关心作用域的问题，往往只有程序出错的时候，我们才会考虑是不是作用域的问题。当然作用域的定义，咱们可以自己百度，网上一大堆解释。</p>\n<ol>\n<li>首先我们得先知道什么东西它有作用域，—-变量，肯定的。不管是简单的数字、Bollen或者字符串，还是object或者函数。他们都有作用域.</li>\n<li>然后我们得知道这个鬼作用域在什么时候出现，或者说，什么情况下会有作用域。javascript中只有当遇到函数的时候，作用域才随之会出现。《权威指南》中在变量作用域这一章节有说明。当然许多前辈都提到function是javascript的一等公民。也许原因就在这儿。</li>\n</ol>\n<p>当然就知道上面两点，我们还不能完全搞懂JS的作用域。前提是我们还得先了解JS的运作机理，就是JS是怎么工作的：</p>\n<ol>\n<li>首先 — 预编译，什么是预编译。预编译就是JS会将<code>var</code>定义的变量<strong>名称</strong>和<code>function</code><strong>整体</strong>以及函数的<code>arguments</code><strong>名称</strong>提前保存起来，也就是《权威指南》中提到的声明提前。JS预编译，只会去获取<strong>名称</strong>和<strong>函数整体</strong>，不会进行操作。","_id":"0puul5bek9getk4w","comments":true,"layout":"post","photos":[],"link":""},{"title":"JS面向对象","date":1400679128000,"tags":["s9cx2zu798wgoc3o"],"categories":["kpn7j6hexozwxcw3"],"content":"<h3 id=\"我对JS面向对象的一些看法\">我对JS面向对象的一些看法</h3>\n<hr>\n<p>面向对象是一个听起来很抽象的概念，以至于我顿时不知道该写什么了。上上个礼拜，写了个小游戏，给老师看了一下，老师给提出用面向对象的编程思想去写，面向对象可以大幅度的降低代码的耦合度。今天闲着没事干，看了老师录的面向对象那一块的视频，终于有了一点看法。<br>扯了那么多，得来点代码消化消化。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> oDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div></pre></td></tr></table></figure>\n\n<p>上面是我们在JS中经常创建对象的方式，当然下面两种咱们基本不用，咱们拿来看看。我们要生成一个对象，我们都是new一个Xxx()出来的，就好比一个厨师要做一个番茄炒蛋，他肯定要把鸡蛋和番茄都new出来才能做菜。但是JS本身并不是菜市场，我想要什么就new什么，但是JS提供了构造函数该我们用，就好比菜市场肯定没有番茄鸡蛋虾米酱，我们只能自己去做了。先看看构造函数：<br><a id=\"more\"></a></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sauce</span><span class=\"params\">(a,b,c)</span></span>{</div><div class=\"line\">\t<span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.b = b;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.c = c;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.getSauce = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a+<span class=\"keyword\">this</span>.b+<span class=\"keyword\">this</span>.c+<span class=\"string\">\"sauce\"</span>;</div><div class=\"line\">\t}</div><div class=\"line\">}</div><div class=\"line\"><span class=\"keyword\">var</span> tes = <span class=\"keyword\">new</span> Sauce(<span class=\"string\">\"tomato\"</span>,<span class=\"string\">\"egg\"</span>,<span class=\"string\">\"shrimp\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(tes.getSauce());</div></pre></td></tr></table></figure>\n\n<p>这样番茄鸡蛋虾米酱，够吃一年了。Sauce这个构造函数就像是一个机器一样，你穿什么进去，它就给你捣鼓什么。突然吃了半年的番茄鸡蛋虾米酱，我们想换换口味了，能不能就拌两种食材呢。我们可以直接在构造函数里面在加一段<code>this.getTwoSauce = function(){···}</code>，当然这样做没问题。但是咱们不想把这个机器拆的七零八落的，在装个什么上去，麻烦，机器还容易拆坏。JS给我们提供了一个很不错的工具。那就是prototype原型。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Sauce.prototype.getTwoSauce = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a+<span class=\"keyword\">this</span>.b+<span class=\"string\">\"sauce\"</span>;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>你会发现我们的机器可以拌两种酱了。</p>\n","source":"_posts/js面向对象.md","raw":"title: JS面向对象\r\ndate: 2014-05-21 21:32:08\r\ntags: 面向对象\r\ncategories: javascript\r\n---\r\n### 我对JS面向对象的一些看法 ###\r\n----------\r\n面向对象是一个听起来很抽象的概念，以至于我顿时不知道该写什么了。上上个礼拜，写了个小游戏，给老师看了一下，老师给提出用面向对象的编程思想去写，面向对象可以大幅度的降低代码的耦合度。今天闲着没事干，看了老师录的面向对象那一块的视频，终于有了一点看法。\r\n扯了那么多，得来点代码消化消化。\r\n```\r\n\tvar oDate = new Date();\r\n\tvar obj = new Object();\r\n\tvar arr = new Array();\r\n```\r\n上面是我们在JS中经常创建对象的方式，当然下面两种咱们基本不用，咱们拿来看看。我们要生成一个对象，我们都是new一个Xxx()出来的，就好比一个厨师要做一个番茄炒蛋，他肯定要把鸡蛋和番茄都new出来才能做菜。但是JS本身并不是菜市场，我想要什么就new什么，但是JS提供了构造函数该我们用，就好比菜市场肯定没有番茄鸡蛋虾米酱，我们只能自己去做了。先看看构造函数： \r\n<!-- more -->\r\n```\r\n\tfunction Sauce(a,b,c){\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t\tthis.getSauce = function(){\r\n\t\t\treturn this.a+this.b+this.c+\"sauce\";\r\n\t\t}\r\n\t}\r\n\tvar tes = new Sauce(\"tomato\",\"egg\",\"shrimp\");\r\n\tconsole.log(tes.getSauce());\r\n```\r\n这样番茄鸡蛋虾米酱，够吃一年了。Sauce这个构造函数就像是一个机器一样，你穿什么进去，它就给你捣鼓什么。突然吃了半年的番茄鸡蛋虾米酱，我们想换换口味了，能不能就拌两种食材呢。我们可以直接在构造函数里面在加一段`this.getTwoSauce = function(){···}`，当然这样做没问题。但是咱们不想把这个机器拆的七零八落的，在装个什么上去，麻烦，机器还容易拆坏。JS给我们提供了一个很不错的工具。那就是prototype原型。\r\n```\r\n\tSauce.prototype.getTwoSauce = function(){\r\n\t\treturn this.a+this.b+\"sauce\";\r\n\t}\r\n```\r\n你会发现我们的机器可以拌两种酱了。","slug":"js面向对象","updated":1416188850000,"excerpt":"<h3 id=\"我对JS面向对象的一些看法\">我对JS面向对象的一些看法</h3>\n<hr>\n<p>面向对象是一个听起来很抽象的概念，以至于我顿时不知道该写什么了。上上个礼拜，写了个小游戏，给老师看了一下，老师给提出用面向对象的编程思想去写，面向对象可以大幅度的降低代码的耦合度。今天闲着没事干，看了老师录的面向对象那一块的视频，终于有了一点看法。<br>扯了那么多，得来点代码消化消化。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> oDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div></pre></td></tr></table></figure>\n\n<p>上面是我们在JS中经常创建对象的方式，当然下面两种咱们基本不用，咱们拿来看看。我们要生成一个对象，我们都是new一个Xxx()出来的，就好比一个厨师要做一个番茄炒蛋，他肯定要把鸡蛋和番茄都new出来才能做菜。但是JS本身并不是菜市场，我想要什么就new什么，但是JS提供了构造函数该我们用，就好比菜市场肯定没有番茄鸡蛋虾米酱，我们只能自己去做了。先看看构造函数：<br>","_id":"k24wuct426886hqr","comments":true,"layout":"post","photos":[],"link":""},{"title":"my project","date":1402671369000,"tags":["n90sclemev191u82"],"categories":["kpn7j6hexozwxcw3"],"content":"<h3 id=\"No-1_2048_GAME\">No.1 2048 GAME</h3>\n<hr>\n<p>整个2048是采用面向过程的去实现的，毕竟是个小游戏。两三百行代码就完事了。<br>整个游戏的核心在于操作两个二维数组，所有的业务逻辑都在数组当中，应用到数组的深拷贝、数组去重、随机数等等。本游戏，采用两个数组实现左右和上下的不同操作；让两个数组紧密相连；但是实现不同的切换状态，当然公用一套算法。最后把数组中的值通过table展现出来。</p>\n<h3 id=\"No2-_Russian_Block\">No2. Russian Block</h3>\n<hr>\n<p>俄罗斯方块是采用‘面向对象’的思想去实现的。当然也是第一次用canvas去写东西，话说canvas挺好，当然IE8以下就不说了。整套游戏并没有去区分7种不同的方块；而是只抓住方块的本质；将7种不同的方块抽象出来；会发现我整套代码里只有一个类：就是方块类。所有的方块公用同一套算法。当然在不同的方块之间还有有一点点小小的区别，主要在变形、创建这两个功能中有区别。</p>\n<h3 id=\"No3-_电商页面\">No3. 电商页面</h3>\n<hr>\n<p>页面仿的京东的主页，其实问题都是写出来的。特别是在兼容IE6的时候。最小高度、浮动元素的横向margin值的问题等等；当然这只是在做兼容中经常出现的问题。当然在对页面布局设计的时候发现，往往一个好的结构不仅能解决兼容问题，也可以为后期的js添加效果省不少事。整个页面有几处要说明一下，一个是京东快报下面的选项卡。内容我大体写了点，没写全；还有就是京东原页面上有了document点击选项卡还原的效果。如果选项卡里面的内容点击之后会有事件冒泡的影响，所以我没做；京东采用的iframe来做的，这样可以解决事件冒泡的问题。还有就是整个页面上有一些遮罩成，我没有去兼容IE；直接用的rgba来做的；在最后的两个热门模块，我的内容是动态创建出来的；所以会造成许多图片的请求；还有就是整个页面没有考究分辨率。</p>\n","source":"_posts/my-project.md","raw":"title: my project\ndate: 2014-06-13 22:56:09\ntags: 项目说明\ncategories:\tjavascript\n---\n### No.1 2048 GAME ###\n----------\n\n\n整个2048是采用面向过程的去实现的，毕竟是个小游戏。两三百行代码就完事了。\n整个游戏的核心在于操作两个二维数组，所有的业务逻辑都在数组当中，应用到数组的深拷贝、数组去重、随机数等等。本游戏，采用两个数组实现左右和上下的不同操作；让两个数组紧密相连；但是实现不同的切换状态，当然公用一套算法。最后把数组中的值通过table展现出来。\n\n### No2. Russian Block ###\n----------\n俄罗斯方块是采用‘面向对象’的思想去实现的。当然也是第一次用canvas去写东西，话说canvas挺好，当然IE8以下就不说了。整套游戏并没有去区分7种不同的方块；而是只抓住方块的本质；将7种不同的方块抽象出来；会发现我整套代码里只有一个类：就是方块类。所有的方块公用同一套算法。当然在不同的方块之间还有有一点点小小的区别，主要在变形、创建这两个功能中有区别。\n\n### No3. 电商页面 ###\n----------\n页面仿的京东的主页，其实问题都是写出来的。特别是在兼容IE6的时候。最小高度、浮动元素的横向margin值的问题等等；当然这只是在做兼容中经常出现的问题。当然在对页面布局设计的时候发现，往往一个好的结构不仅能解决兼容问题，也可以为后期的js添加效果省不少事。整个页面有几处要说明一下，一个是京东快报下面的选项卡。内容我大体写了点，没写全；还有就是京东原页面上有了document点击选项卡还原的效果。如果选项卡里面的内容点击之后会有事件冒泡的影响，所以我没做；京东采用的iframe来做的，这样可以解决事件冒泡的问题。还有就是整个页面上有一些遮罩成，我没有去兼容IE；直接用的rgba来做的；在最后的两个热门模块，我的内容是动态创建出来的；所以会造成许多图片的请求；还有就是整个页面没有考究分辨率。\n","slug":"my-project","updated":1416374970000,"excerpt":"","_id":"l2lst50rt9g5qs4i","comments":true,"layout":"post","photos":[],"link":""},{"title":"THIS的只读操作","date":1400827350000,"tags":["7arxjohxrcsdwefg"],"categories":["kpn7j6hexozwxcw3"],"content":"<h3 id=\"this是一个只读的对象\">this是一个只读的对象</h3>\n<hr>\n<p>在我们写前端效果的时候，几乎不可能不去跟this打交道，this太方便了，相当方便，我在写代码的时候总是会往this上面靠。但是要是想把握好this的指向性，写代码的时候就要非常的细心。当然前提条件是你对this有足够的了解。先来看看this的常用场景。<br>出入JS，我们经常写出下面的代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>{</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> aLi = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</div><div class=\"line\"> \t\t<span class=\"keyword\">for</span>( <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; aLi.length; i++){</div><div class=\"line\"> \t\t\taLi[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{</div><div class=\"line\"> \t\t\t\t<span class=\"keyword\">this</span>.style.background = <span class=\"string\">'red'</span>;</div><div class=\"line\"> \t\t\t}</div><div class=\"line\"> \t\t}</div><div class=\"line\">\t}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p><a id=\"more\"></a><br>在上面的代码中，我们发现this在Li元素的点击事件中起到了最为关键的作用，这个时候this就指向了发生点击事件的对象。一般情况下，在事件函数内，this都指向发生事件的对象。这也很容易理解。<br>想必对JS作用域有所了解的同学，都知道JS里面有个叫闭包的东西。我们看下面的代码就清楚了。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span><span class=\"params\">()</span></span>{</div><div class=\"line\">\t<span class=\"keyword\">var</span> a = {name : <span class=\"string\">\"laodie\"</span>};</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span><span class=\"params\">()</span></span>{</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> b = <span class=\"string\">\"erzi\"</span>;</div><div class=\"line\">\t\talert(a.name);</div><div class=\"line\">\t}</div><div class=\"line\">\tfn2();</div><div class=\"line\">\talert(b);</div><div class=\"line\">}</div><div class=\"line\">\tfn1();</div></pre></td></tr></table></figure>\n\n<p>我们会发现在fn2中并没有声明a变量，但是程序并没有报错，反而把fn1里面的a弹出来了；但是fn1却没有访问到b，直接报错<code>b is not defined</code>。这就是闭包：简单的说就是老爸的家儿子可以随意进出，想拿什么就拿什么；不过儿子的家，老爸连门都碰不着,(坑爹吧)。但是我们this讲的好好的为什么突然扯到闭包上面呢。其实，下面的代码说明了我的目的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{</div><div class=\"line\">\t<span class=\"keyword\">var</span> aLi = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</div><div class=\"line\"> \t<span class=\"keyword\">for</span>( <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; aLi.length; i++){</div><div class=\"line\"> \t\taLi[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{</div><div class=\"line\"> \t\t\t<span class=\"keyword\">this</span>.style.background = <span class=\"string\">'red'</span>;</div><div class=\"line\"> \t\t\t(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{alert(<span class=\"keyword\">this</span>)})();</div><div class=\"line\"> \t\t}</div><div class=\"line\"> \t}</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>我们会发现原来我们想了利用闭包，在子函数内部使用li元素的，可是子函数内部的this却指向了window。我们发现虽然儿子可以随意访问老爸的地盘，可以想拿什么就拿什么。不过儿子不能把老爸从老爸的家里轰出来吧。所以我的得出一个结论：this只有在本函数内部其实际指向性才有效。当然子函数的this始终指向window。当然我们要想访问父级函数的this并不是没有办法，我们可以把父级的this传递给一个变量<code>var _this = this</code>，这样我们在子级函数内部就可以访问了。<br>当然当我们使用定时器的时候，我们在使用this时候，也会遇到同上的问题，this指向了window。办法也是将this传递给其他变量，同过变量去操作this。<br>我们在采用构造函数生成对象的时候，我们也碰到this：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">This</span><span class=\"params\">(n,a)</span></span>{</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = n;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.age = a</div><div class=\"line\">}</div><div class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"keyword\">new</span> This(<span class=\"string\">'towne'</span>,<span class=\"number\">24</span>);</div><div class=\"line\">alert(_this.name+<span class=\"string\">\"今年\"</span>+_this.age+<span class=\"string\">\"岁\"</span>);</div></pre></td></tr></table></figure>\n\n<p>我们发现在构造函数内部，this是不具备指向性的，只有new一个实例化的对象后this才会具有指向性，而且就是指向new出来的实例对象。<br>当然，大晚上的咱们目的不是在关注this的指向性。咱们在写代码的是时候，咱们从来没有写过这样的代码吧<code>this = null</code>；当然以后也千万不要写；我们虽然频繁的使用this，可是千万要记住this我们可以修改它的方法和属性；不过我们不能对它本身进行操作。就是说<strong>this</strong>本身是只能读取的，不能进出写操作。而<code>this.className</code>这些this下面的属性和方法，我们是可以读取和写操作的。大晚上的热的一米。2014/5/24 0:11:56 </p>\n","source":"_posts/this的只读操作.md","raw":"title: THIS的只读操作\r\ndate: 2014-05-23 14:42:30\r\ntags: this\r\ncategories: javascript\r\n---\r\n### this是一个只读的对象 ###\r\n----------\r\n在我们写前端效果的时候，几乎不可能不去跟this打交道，this太方便了，相当方便，我在写代码的时候总是会往this上面靠。但是要是想把握好this的指向性，写代码的时候就要非常的细心。当然前提条件是你对this有足够的了解。先来看看this的常用场景。\r\n出入JS，我们经常写出下面的代码：\r\n```\r\n\t<script type=\"text/javascript\">\r\n\t\twindow.onload = function (){\r\n\t\t\tvar aLi = document.getElementsByTagName('li');\r\n\t \t\tfor( var i = 0; i < aLi.length; i++){\r\n\t \t\t\taLi[i].onclick = function(){\r\n\t \t\t\t\tthis.style.background = 'red';\r\n\t \t\t\t}\r\n\t \t\t}\r\n\t\t}\r\n\t</script>\r\n```\r\n<!-- more -->\r\n在上面的代码中，我们发现this在Li元素的点击事件中起到了最为关键的作用，这个时候this就指向了发生点击事件的对象。一般情况下，在事件函数内，this都指向发生事件的对象。这也很容易理解。\r\n想必对JS作用域有所了解的同学，都知道JS里面有个叫闭包的东西。我们看下面的代码就清楚了。\r\n```\r\n\tfunction fn1(){\r\n\t\tvar a = {name : \"laodie\"};\r\n\t\tfunction fn2(){\r\n\t\t\tvar b = \"erzi\";\r\n\t\t\talert(a.name);\r\n\t\t}\r\n\t\tfn2();\r\n\t\talert(b);\r\n\t}\r\n \tfn1();\r\n```\r\n我们会发现在fn2中并没有声明a变量，但是程序并没有报错，反而把fn1里面的a弹出来了；但是fn1却没有访问到b，直接报错`b is not defined`。这就是闭包：简单的说就是老爸的家儿子可以随意进出，想拿什么就拿什么；不过儿子的家，老爸连门都碰不着,(坑爹吧)。但是我们this讲的好好的为什么突然扯到闭包上面呢。其实，下面的代码说明了我的目的：\r\n```\r\n\twindow.onload = function(){\r\n\t\tvar aLi = document.getElementsByTagName('li');\r\n\t \tfor( var i = 0; i < aLi.length; i++){\r\n\t \t\taLi[i].onclick = function(){\r\n\t \t\t\tthis.style.background = 'red';\r\n\t \t\t\t(function(){alert(this)})();\r\n\t \t\t}\r\n\t \t}\r\n\t}\r\n```\r\n我们会发现原来我们想了利用闭包，在子函数内部使用li元素的，可是子函数内部的this却指向了window。我们发现虽然儿子可以随意访问老爸的地盘，可以想拿什么就拿什么。不过儿子不能把老爸从老爸的家里轰出来吧。所以我的得出一个结论：this只有在本函数内部其实际指向性才有效。当然子函数的this始终指向window。当然我们要想访问父级函数的this并不是没有办法，我们可以把父级的this传递给一个变量`var _this = this`，这样我们在子级函数内部就可以访问了。\r\n当然当我们使用定时器的时候，我们在使用this时候，也会遇到同上的问题，this指向了window。办法也是将this传递给其他变量，同过变量去操作this。\r\n我们在采用构造函数生成对象的时候，我们也碰到this：\r\n```\r\n\tfunction This(n,a){\r\n\t\tthis.name = n;\r\n\t\tthis.age = a\r\n\t}\r\n\tvar _this = new This('towne',24);\r\n\talert(_this.name+\"今年\"+_this.age+\"岁\");\r\n```\r\n我们发现在构造函数内部，this是不具备指向性的，只有new一个实例化的对象后this才会具有指向性，而且就是指向new出来的实例对象。\r\n当然，大晚上的咱们目的不是在关注this的指向性。咱们在写代码的是时候，咱们从来没有写过这样的代码吧`this = null`；当然以后也千万不要写；我们虽然频繁的使用this，可是千万要记住this我们可以修改它的方法和属性；不过我们不能对它本身进行操作。就是说**this**本身是只能读取的，不能进出写操作。而`this.className`这些this下面的属性和方法，我们是可以读取和写操作的。大晚上的热的一米。2014/5/24 0:11:56 \r\n\r\n","slug":"this的只读操作","updated":1416188850000,"excerpt":"<h3 id=\"this是一个只读的对象\">this是一个只读的对象</h3>\n<hr>\n<p>在我们写前端效果的时候，几乎不可能不去跟this打交道，this太方便了，相当方便，我在写代码的时候总是会往this上面靠。但是要是想把握好this的指向性，写代码的时候就要非常的细心。当然前提条件是你对this有足够的了解。先来看看this的常用场景。<br>出入JS，我们经常写出下面的代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">script</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>{</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> aLi = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</div><div class=\"line\"> \t\t<span class=\"keyword\">for</span>( <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; aLi.length; i++){</div><div class=\"line\"> \t\t\taLi[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>{</div><div class=\"line\"> \t\t\t\t<span class=\"keyword\">this</span>.style.background = <span class=\"string\">'red'</span>;</div><div class=\"line\"> \t\t\t}</div><div class=\"line\"> \t\t}</div><div class=\"line\">\t}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n\n<p>","_id":"hwk437tfzbo6axvb","comments":true,"layout":"post","photos":[],"link":""},{"title":"创建DOM元素的问题","date":1401002006000,"tags":["l17mwhqxl3om0acl"],"categories":["kpn7j6hexozwxcw3"],"content":"","source":"_posts/创建dom元素的问题.md","raw":"title: 创建DOM元素的问题\ndate: 2014-05-25 15:13:26\ntags: DOM节点\t\ncategories:\tjavascript\n---\n","slug":"创建dom元素的问题","updated":1416188850000,"excerpt":"","_id":"h70fad9faohpc4rc","comments":true,"layout":"post","photos":[],"link":""},{"title":"NODEJS热身一","date":1410620169000,"tags":["gx27qavlrqrjft83","0f7lba3be0pxvyjh"],"categories":["x5nen7h4vpv1cgo3"],"content":"<h3 id=\"NODEJS起源\">NODEJS起源</h3>\n<p>nodejs的诞生与javascript的崛起是有着本质的联系的，用javascript这一弱类型语言去写后端服务，已经是一段历史了。但是nodejs之所以能力揽狂澜，google的V8引擎是功不可没，当然越来越多的程序员投身web前端技术开发，也是给nodejs的发展奠定的人才基础。<br>nodejs诞生于2009年，Ryan Dahl将V8引入后端，将C++和javascript两种语言结合，创造出一门新的后端技术－－NODEJS。<br>2010年，随着ECMAScript5的发布，nodejs的发展的非常快。越拉越多的公司都加入nodejs开发队伍中来，涌现出一大批优秀的项目。</p>\n<h3 id=\"NODEJS的特点\">NODEJS的特点</h3>\n<p>nodejs的最大的特点：事件驱动，这跟浏览器段的javascript的事件驱动很像，事件驱动很好的支持了nodejs的I/O大并发。当然不得不说的就是nodejs的单线程，在单线程的基础之上加入事件驱动，很好的避免的阻塞操作。非阻塞I/O就是nodejs的一大特色，当然随着nodejs引入child_process模块，单线程的短板得到很大的改善。</p>\n","source":"_posts/nodejs热身一.md","raw":"title: NODEJS热身一\ndate: 2014-09-13 22:56:09\ntags: [\"javascript\",\"nodejs\"]\ncategories:\tnodejs\n---\n### NODEJS起源 ###\nnodejs的诞生与javascript的崛起是有着本质的联系的，用javascript这一弱类型语言去写后端服务，已经是一段历史了。但是nodejs之所以能力揽狂澜，google的V8引擎是功不可没，当然越来越多的程序员投身web前端技术开发，也是给nodejs的发展奠定的人才基础。\nnodejs诞生于2009年，Ryan Dahl将V8引入后端，将C++和javascript两种语言结合，创造出一门新的后端技术－－NODEJS。\n2010年，随着ECMAScript5的发布，nodejs的发展的非常快。越拉越多的公司都加入nodejs开发队伍中来，涌现出一大批优秀的项目。\n### NODEJS的特点 ###\nnodejs的最大的特点：事件驱动，这跟浏览器段的javascript的事件驱动很像，事件驱动很好的支持了nodejs的I/O大并发。当然不得不说的就是nodejs的单线程，在单线程的基础之上加入事件驱动，很好的避免的阻塞操作。非阻塞I/O就是nodejs的一大特色，当然随着nodejs引入child_process模块，单线程的短板得到很大的改善。","slug":"nodejs热身一","updated":1416376979000,"excerpt":"","_id":"kc4xi4n6vm81yt9w","comments":true,"layout":"post","photos":[],"link":""}],"Tag":[{"name":"css","_id":"cinq56dlu69hhr5s","posts":["2g8v2h5wq1dneiqe"]},{"name":"layout","_id":"kjkc0phd1g8rw3fu","posts":["4dji7sn1vmedp04e"]},{"name":"object","_id":"aw2ys0u363x3e3up","posts":["yn8699821c12i2sh"]},{"name":"作用域","_id":"6ozzr8txhwusnkke","posts":["0puul5bek9getk4w"]},{"name":"面向对象","_id":"s9cx2zu798wgoc3o","posts":["k24wuct426886hqr"]},{"name":"项目说明","_id":"n90sclemev191u82","posts":["l2lst50rt9g5qs4i"]},{"name":"this","_id":"7arxjohxrcsdwefg","posts":["hwk437tfzbo6axvb"]},{"name":"DOM节点","_id":"l17mwhqxl3om0acl","posts":["h70fad9faohpc4rc"]},{"name":"js","_id":"mhd0jok67t3zffd2","posts":[]},{"name":"javascript","_id":"gx27qavlrqrjft83","posts":["kc4xi4n6vm81yt9w"]},{"name":"nodejs","_id":"0f7lba3be0pxvyjh","posts":["kc4xi4n6vm81yt9w"]}]}